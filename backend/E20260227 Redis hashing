# Redis vs Java hashTable
Redis	Java HashMap
해시 함수	SipHash (HashDoS 공격 방지에 초점)	hashCode() + 보조 해시 함수 (키 분포 개선에 초점)
기본 충돌 해결	체이닝 (연결 리스트)	체이닝 (연결 리스트)
충돌 심화 시	해결책 없음. 연결 리스트가 길어짐. (단, 점진적 리해싱으로 테이블을 확장하여 충돌 확률 자체를 낮춤)	균형 이진 트리 (Red-Black Tree)로 변환 (Java 8 이상)
최악의 시간 복잡도	O(N) (이론상 가능하지만, SipHash와 리해싱으로 거의 발생하지 않음)	O(logN) (Java 8 이상)
리사이징	점진적 리해싱 (서비스 중단 없음)	전체 리해싱 (테이블 확장 시 모든 키를 한 번에 재배치, 약간의 지연 발생 가능)

# 해싱
Redis는 특정 해시 함수를 사용하여 키를 해시 테이블의 인덱스로 변환하고, **체이닝(Chaining)**이라는 기법으로 해시 충돌을 해결합니다. 또한, 성능 저하를 막기 위해 **점진적 리해싱(Incremental Rehashing)**이라는 독창적인 방법으로 해시 테이블을 확장합니다.

1. 어떤 해시 함수를 사용하는가?
Redis는 버전에 따라 다른 해시 함수를 사용해왔습니다.

A. SipHash (현재, Redis 2.6 이상)
현재 Redis의 표준 해시 함수는 SipHash 입니다.
선택 이유: 속도도 빠르지만, 가장 중요한 이유는 보안성입니다.
보안성 (HashDoS 공격 방지): 과거에 사용되던 MurmurHash 같은 함수들은 알고리즘이 공개되어 있고 예측 가능성이 일부 있었습니다. 이를 악용하면 공격자가 의도적으로 해시 충돌을 대량으로 일으키는 키들을 서버에 전송할 수 있습니다. 충돌이 많아지면 특정 버킷의 연결 리스트가 매우 길어져서, 해당 버킷을 조회할 때마다 성능이 O(1)에서 O(N)으로 급격히 저하되어 서버를 마비시킬 수 있습니다. 이를 **해시 충돌 공격(HashDoS, Hash Denial of Service)**이라고 합니다.
SipHash는 매번 실행 시마다 랜덤한 key(비밀 값)를 사용해 해시 값을 생성하므로, 외부 공격자가 해시 결과를 예측하기가 거의 불가능합니다. 따라서 이러한 공격에 매우 안전합니다.
B. MurmurHash2 (과거, Redis 2.6 미만)
과거에는 속도가 매우 빠른 것으로 알려진 MurmurHash2를 사용했습니다.
이 함수는 키를 해시 테이블에 매우 잘 분산시켜주지만, 위에 언급된 HashDoS 공격에 취약한 단점이 있어 SipHash로 교체되었습니다.
요약: Redis는 속도와 분산 능력도 중요하지만, 서비스 안정성을 해칠 수 있는 보안 위협에 대응하기 위해 더 안전한 SipHash를 채택했습니다.

2. 해시 충돌이 발생하면 어떻게 해결하는가? - 체이닝 (Chaining)
서로 다른 키가 해시 함수를 거쳤을 때 우연히 같은 결과값(인덱스)을 갖게 되는 것을 **해시 충돌(Hash Collision)**이라고 합니다. Redis는 이 문제를 체이닝(Chaining), 또는 **분리 연결법(Separate Chaining)**이라고 불리는 기법으로 해결합니다.

아파트 단지에 비유하여 쉽게 설명해 보겠습니다.

해시 테이블: 아파트 단지 전체 (예: 10개 동)
버킷 (Bucket): 각 아파트 동 (1동, 2동, ... 10동)
해시 함수 결괏값: 입주할 동 번호
Key-Value 쌍: 입주할 가족
상황: A 가족(mykey)과 B 가족(yourkey)이 입주 신청을 했는데, 우연히 둘 다 '5동'을 배정받았습니다. (해시 충돌 발생)

해결책 (체이닝):
아파트 관리사무소(Redis)는 B 가족을 쫓아내거나 다른 동으로 보내지 않습니다. 대신, 5동 건물을 위로 증축하여 2층을 만들고 B 가족을 입주시킵니다. 즉, 각 버킷(동)을 연결 리스트(Linked List) 자료구조로 만들어, 같은 인덱스를 가진 Key-Value 쌍들을 체인처럼 계속 엮어 나가는 방식입니다.

